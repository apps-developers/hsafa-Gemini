---
title: Distributed Agent Platform Architecture
description: Building an Agent Builder + Distributed Agent Runtime with persistent memory and distributed tool execution.
---

# üß† The Big Idea

You are building an **Agent Builder + Distributed Agent Runtime**

A system where:

* Users **create agents** via config
* Agents run **on your server**
* Any client (web, mobile, node app) can:
  * Start a run
  * Watch it stream
  * Refresh and reconnect
* Agents can call **tools that run anywhere** (server, browser, other devices)

This is like giving AI agents a **backend, memory, and a network of devices**.

---

# üèóÔ∏è System Architecture

## 1Ô∏è‚É£ Agent Builder (Control Plane)

Users send agent configs:

```json
{
  "name": "research-agent",
  "model": "gpt-5",
  "systemPrompt": "...",
  "tools": [...]
}
```

You:

* Store config in **PostgreSQL**
* Cache hot agents in **Redis or memory**
* Reuse config when runs start

---

## 2Ô∏è‚É£ Agent Runtime (Execution Plane)

When a user starts a run:

1. Load agent config
2. Load chat history
3. Start the agent using **Vercel AI SDK Core**
4. Stream output
5. Handle tool calls
6. Save everything

The SDK is only the **brain**.
Your system is the **body + memory + network**.

---

# üíæ Storage Layers

## üóÑ PostgreSQL (Permanent Memory)

Stores long-term data:

### Tables

**agents**

* id
* name
* description

**agent_versions**

* id
* agent_id
* version
* config_json
* config_hash

**runs**

* id
* agent_id
* agent_version_id
* status (queued / running / waiting_tool / completed / failed / canceled)

**run_events**

* id
* run_id
* seq
* type
* payload

**tool_calls**

* run_id
* call_id
* tool_name
* args
* execution_target (server/device/browser/external)
* status

**tool_results**

* run_id
* call_id
* result
* source (server/device/browser)

**devices**

* id
* device_key
* capabilities
* last_seen_at

This lets any client reload full history.

---

## ‚ö° Redis (Live Memory)

Used for **realtime + streaming state**

### Redis Streams

Key per run:

```
run:{runId}:stream
```

Stores:

* text chunks
* tool call events
* tool results
* status updates

This allows:
‚úÖ Resume after refresh
‚úÖ Multiple clients watching same run
‚úÖ No lost streaming data

---

# üåä Streaming Flow

### Agent ‚Üí Redis

While model streams:

```
XADD run:123:stream chunk "Hello"
XADD run:123:stream chunk " world"
```

### Client ‚Üí Server (SSE)

Client subscribes:

```
GET /api/runs/123/stream
```

Server reads Redis stream and pushes events.

If page refreshes:

* Client reconnects
* Server continues from last event ID
* Stream resumes seamlessly

---

# üõ† Tool System (Distributed Execution)

This is the powerful part.

Agents can call tools that run:

| Location    | Example                  |
| ----------- | ------------------------ |
| Server      | DB queries, APIs         |
| Browser     | Local files, camera      |
| Node client | Company internal systems |

---

## üîÑ Tool Call Lifecycle

### 1Ô∏è‚É£ Agent requests tool

SDK emits a tool call ‚Üí you intercept

You store event and publish:

```json
{
  "type": "tool.call",
  "toolCallId": "abc123",
  "toolName": "scanFiles",
  "args": {"...": "..."},
  "executionTarget": "device"
}
```

Saved in:

* PostgreSQL (history)
* Redis Stream (live)

### 2Ô∏è‚É£ Target Client Executes Tool

Client connected via WebSocket receives the request, runs the tool locally, and sends back:

```json
{
  "type": "tool.result",
  "toolCallId": "abc123",
  "result": {...}
}
```

---

### 3Ô∏è‚É£ Server Resumes Agent

You feed result back into the model:

```
assistant ‚Üê tool result
```

Agent continues streaming as if nothing happened.

All watchers see this live via Redis stream.

---

# üß† Role of Vercel AI SDK (Core Only)

You DO NOT use:
‚ùå `useChat` 
‚ùå AI SDK UI helpers

You ONLY use:

| Function             | Purpose                                |
| -------------------- | -------------------------------------- |
| `ToolLoopAgent`      | Runs the tool loop + model decisions   |
| `agent.stream(...)`  | Streams parts (text + tools + steps)   |
| Tool calling support | Let model decide when tools are needed |

You handle:

* Tool execution
* Message storage
* Streaming infra
* Run lifecycle

SDK = **decision engine only**

---

# üóÑÔ∏è PostgreSQL Schema (Current)

This is a recommended baseline schema that supports:

- Persistent agent configs + versioning
- Persistent run state + resume
- Durable event log (can always rebuild UI from it)
- Distributed tool calls + results
- Device registry

## Core Types

- `uuid` ids everywhere
- `jsonb` for agent config and tool payloads
- `timestamptz` for all timestamps

## Tables (Baseline)

### `agents`

- **Purpose**: logical agent identity (stable).

Recommended columns:

- `id uuid pk`
- `name text not null`
- `description text null`
- `created_at timestamptz not null default now()`
- `updated_at timestamptz not null default now()`

Indexes/constraints:

- Unique: `(name)`

### `agent_versions`

- **Purpose**: immutable snapshots of agent configs.

Recommended columns:

- `id uuid pk`
- `agent_id uuid not null fk -> agents(id)`
- `version text not null` (semver or timestamp-based)
- `config_json jsonb not null`
- `config_hash text not null` (sha256 for idempotent publish)
- `metadata jsonb null`
- `created_at timestamptz not null default now()`

Indexes/constraints:

- Unique: `(agent_id, version)`
- Unique: `(agent_id, config_hash)`

### `runs`

- **Purpose**: a single execution instance.

Recommended columns:

- `id uuid pk`
- `agent_id uuid not null`
- `agent_version_id uuid not null`
- `status text not null` (`queued|running|waiting_tool|completed|failed|canceled`)
- `started_at timestamptz null`
- `completed_at timestamptz null`
- `error_message text null`
- `created_at timestamptz not null default now()`
- `updated_at timestamptz not null default now()`

Indexes:

- `(status, updated_at desc)`
- `(agent_id, created_at desc)`

### `run_events`

- **Purpose**: canonical event log for UI + recovery.

Recommended columns:

- `id uuid pk`
- `run_id uuid not null fk -> runs(id)`
- `seq bigint not null` (monotonic per run)
- `type text not null`
- `payload jsonb not null`
- `created_at timestamptz not null default now()`

Indexes/constraints:

- Unique: `(run_id, seq)`
- Index: `(run_id, created_at)`

### `tool_calls`

- **Purpose**: tool invocation state.

Recommended columns:

- `id uuid pk`
- `run_id uuid not null fk -> runs(id)`
- `call_id text not null` (provided by runtime; unique per run)
- `tool_name text not null`
- `args jsonb not null`
- `execution_target text not null` (`server|device|browser|external`)
- `status text not null` (`requested|dispatched|completed|failed|expired`)
- `requested_at timestamptz not null default now()`
- `completed_at timestamptz null`
- `error_message text null`

Indexes/constraints:

- Unique: `(run_id, call_id)`
- Index: `(execution_target, status)`

### `tool_results`

- **Purpose**: tool result storage.

Recommended columns:

- `id uuid pk`
- `run_id uuid not null fk -> runs(id)`
- `call_id text not null`
- `result jsonb not null`
- `source text not null` (`server|device|browser`)
- `created_at timestamptz not null default now()`

Indexes/constraints:

- Unique: `(run_id, call_id)`

### `devices`

- **Purpose**: device registry.

Recommended columns:

- `id uuid pk`
- `device_key text not null` (unique identifier)
- `capabilities jsonb not null` (list of supported tools)
- `last_seen_at timestamptz null` (timestamp of last heartbeat)

Indexes/constraints:

- Unique: `(device_key)`

---

# ‚ö° Redis Schema (Current)

Redis is for:

- Stream replay (SSE reconnect)
- Fast fanout to many watchers
- Fast routing of tool requests to devices
- Ephemeral coordination (locks, heartbeats, transient state)

## Key Naming Convention

- `run:{runId}:stream` (Redis Stream)
- `run:{runId}:notify` (Pub/Sub)
- `device:{deviceId}:inbox` (Redis Stream or Pub/Sub channel)
- `device:{deviceId}:presence` (String or Hash, TTL)

## Redis Streams

### `run:{runId}:stream`

- **Type**: Redis Stream
- **Purpose**: replayable event stream for SSE and ‚Äúmultiple watchers‚Äù.

Entry format (recommended):

- Field: `type` (string)
- Field: `ts` (ISO string or unix ms)
- Field: `payload` (JSON string)

Example:

```
XADD run:123:stream * type "assistant.delta" ts "2026-01-30T12:00:00.000Z" payload "{...}"
```

Retention:

- Use `XTRIM run:{runId}:stream MAXLEN ~ 10000` (or time-based trim)
- Optional: keep full history in Postgres; Redis is just a hot window.

---

# üß¨ Event & Message Protocol (Current)

Gateway SSE events use a single envelope:

```json
{
  "id": "1738400000000-0",
  "type": "text.delta",
  "ts": "2026-01-30T12:00:00.000Z",
  "data": {}
}
```

## Event Types (examples from current runtime)

- `run.created`
- `run.started`
- `text.delta`
- `message.user`
- `message.assistant`
- `tool.call`
- `tool.result`
- `run.completed`
- `run.failed`

## SSE Contract

- Endpoint: `GET /api/runs/:runId/stream`
- Client reconnect:
  - sends `Last-Event-ID: <redisStreamId>`
  - or `?since=<redisStreamId>`

Server behavior:

- Read Redis stream with `XREAD` starting at the provided id.
- For each entry, emit:

```
id: <redisStreamId>
event: hsafa
data: {"runId":...,"seq":...,"type":...,"ts":...,"data":...}

```

---

# üîå API Surface (Gateway, Current)

Current endpoints:

- `POST /api/agents` (create agent + create version if config changed)
- `GET  /api/runs?agentId=...` (list runs)
- `POST /api/runs` (create run)
- `POST /api/runs/:runId/messages` (append user message and start/resume run)
- `GET  /api/runs/:runId` (run state)
- `GET  /api/runs/:runId/events` (Postgres event history)
- `GET  /api/runs/:runId/stream` (SSE from Redis)
- `POST /api/runs/:runId/tool-results` (submit tool result)
- `GET  /api/agent-config/:agentName` (legacy)
- `WS   /devices/connect` (device registration + tool results)

---
